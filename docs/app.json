[{"name":"app.R","content":"library(shiny)\nlibrary(shinyjs)\nNplayer = 6\nNmilk = 4\n\nmostProbCol = function(MilkMatrix){\n  freqTab = rep(0,ncol(MilkMatrix))\n  nmc = 1e3\n  iter = 0\n  while(iter<nmc){\n    tmp = apply(MilkMatrix,2,function(x){sample(x,1)})\n    idx = which(tmp == max(tmp))\n    freqTab[idx] = freqTab[idx]+1\n    iter = iter+1\n  }\n  return(which(freqTab == max(freqTab)))\n}\n\n# Define UI for random distribution app ----\nui <- fluidPage(\n  shinyjs::useShinyjs(),\n\n  # App title ----\n  titlePanel(\"Pick the best\"),\n  wellPanel(\n\n  # Sidebar layout with input and output definitions ----\n  sidebarLayout(\n\n    # Sidebar panel for inputs ----\n    sidebarPanel(\n\n      actionButton(\"updateData\", \"NEXT DATA\"),\n      actionButton(\"updateChoice\", \"NEXT CHOICE\"),\n      actionButton('resetButton',\"BigBoyReset\"),\n\n      # Input: Selector for milk ----\n      selectInput(\"choice\", \"Make your choice:\",\n                  c(1:Nmilk))\n\n      \n      # actionButton(\"Button1\", \"Run\"),\n      # shinyjs::hidden(p(id = \"text1\", \"Processing...\"))\n    ),\n\n    # Main panel for displaying outputs ----\n    mainPanel(\n\n      # Output: Tabset w/ plot, summary, and table ----\n      tabsetPanel(type = \"tabs\",\n                  tabPanel(\"Plot\", plotOutput(\"plot\")),\n                  tabPanel(\"Summary\", verbatimTextOutput(\"summary\")),\n                  tabPanel(\"Table\", tableOutput(\"table\"))\n      )\n\n    )\n  )),\n  wellPanel(\n    fluidRow(verbatimTextOutput(\"phase\"))\n  ),\n  wellPanel(\n    fluidRow(tableOutput(\"Results\"))\n  )\n\n)\n\n# Define server logic for random distribution app ----\nserver <- function(input, output, session) {\n\n  Accrued = reactiveVal(rep(0,Nplayer+1))\n  Niter = reactiveVal(0)\n\n\n  currPhase = reactiveVal(TRUE) # !resultPhase\n\n  currResult = reactiveVal(NULL)\n\n\n  NPCchoice = reactiveVal(NULL)\n  shinyjs::disable(\"updateData\")\n\n  # initial ----\n  mus = rnorm(Nmilk)+100\n  sig = 1/rgamma(Nmilk, 5, 5)\n\n  x = matrix(rnorm(1e2*Nmilk,mus, sig),nrow = 1e3, ncol = Nmilk,\n            byrow = TRUE)\n  # boxplot(x)\n  MilkMatrix <- reactiveVal(x)\n\n\n  # eventReactive expression to generate the requested distribution ----\n\n\n  \n# ==========================================================================\n# Update the data ----\n# ==========================================================================\n  observeEvent(input$updateData,{\n\n    mus = rnorm(Nmilk)+100\n    sig = 1/rgamma(Nmilk, 5, 5)\n\n    x = matrix(rnorm(1e2*Nmilk,mus, sig),nrow = 1e3, ncol = Nmilk,\n              byrow = TRUE)\n    MilkMatrix(x)\n\n    newPhase = !currPhase()\n    currPhase(newPhase)\n    shinyjs::enable(\"updateChoice\")\n    shinyjs::disable(\"updateData\")\n  })\n  \n# ==========================================================================\n# Update the choice ----\n# ==========================================================================\n  observeEvent(input$updateChoice,{\n\n    currResult(sample(seq(Nmilk),1))\n\n\n    newPhase = !currPhase()\n    currPhase(newPhase)\n\n    tmpRes = MilkMatrix()[currResult(),]\n\n    tmpProfit = rep(0,Nplayer+1)\n\n\n    # Player ----\n    tmpProfit[1] = tmpRes[as.numeric(input$choice)]\n    # NPC ----\n\n    tmpSmm = rbind(colMeans(MilkMatrix()),\n                apply(MilkMatrix(), 2, quantile, probs = 0.025),\n                apply(MilkMatrix(), 2, quantile, probs = 0.975),\n                apply(MilkMatrix(),2, median)\n                )\n\n    tmpNPC = rep(NA, Nplayer)\n\n    tmpNPC[1] = which(tmpSmm[1,] == max(tmpSmm[1,]) )\n    tmpNPC[2] = which(tmpSmm[2,] == max(tmpSmm[2,]) )\n    tmpNPC[3] = which(tmpSmm[3,] == max(tmpSmm[3,]) )\n    tmpNPC[4] = which(tmpSmm[4,] == max(tmpSmm[4,]) )\n    tmpNPC[5] = mostProbCol(MilkMatrix())\n    tmpNPC[6] = sample(seq(Nmilk),1)\n\n\n    tmpProfit[2:7] = tmpRes[tmpNPC]\n\n    Accrued(Accrued() +tmpProfit)\n    print(tmpNPC)\n    NPCchoice(tmpNPC)\n\n\n    \n    Niter(Niter()+1)\n    shinyjs::disable(\"updateChoice\")\n    shinyjs::enable(\"updateData\")\n  })\n\n\n\n  # Generate a plot of the data ----\n  # Also uses the inputs to build the plot label. Note that the\n  # dependencies on the inputs and the data reactive expression are\n  # both tracked, and all expressions are called in the sequence\n  # implied by the dependency graph.\n  output$plot <- renderPlot({\n    boxplot(MilkMatrix())\n    if(!currPhase()){\n      points(1:Nmilk, MilkMatrix()[currResult(),], lwd = 3, cex = 1.5,\n        col = 'red')\n      points(as.numeric(input$choice), MilkMatrix()[currResult(),][as.numeric(input$choice)],\n         col = 'blue', lwd = 3, pch = 3)\n\n      points(NPCchoice(), MilkMatrix()[currResult(),][NPCchoice()],\n         col = 'green', lwd = 3, pch = 3)\n\n    }\n  })\n\n  # Generate a summary of the data ----\n  output$summary <- renderPrint({\n    summary(MilkMatrix())\n  })\n\n  # Generate an HTML table view of the data ----\n  output$table <- renderTable({\n    head(MilkMatrix())\n  })\n\n  output$Results <- renderTable({\n    # tmp = Accrued()\n    # names(tmp) = c(\"Player\", paste0(\"NPC_\",1:Nplayer))\n    # tmp\n    tmp = data.frame(matrix(Accrued(),1,Nplayer+1))\n    colnames(tmp) = c(\"Player\", paste0(\"NPC_\",1:Nplayer))\n    tmp\n  })\n\n\n\n  output$phase <- renderPrint({\n    cat(paste0(\"currPhase:\", currPhase(),\"\\n\",\n      \"profit: \", Accrued()[1],\"\\n\",\n      \"runningAverage: \", round(Accrued()/Niter(),2))[1])\n  })\n\n  observeEvent(input$resetButton,{\n    aggg_result = -1\n    if(aggg_result == -1)\n    {\n      session$reload()\n      return()\n      print(\"session reload not working\")\n    }\n\n    print(\"Code running this line\")\n\n    output$code_ran <- renderText(\"code Ran this line without refreshing\")\n\n  })\n\n  # plotReady <- reactiveValues(ok = FALSE)\n\n  # observeEvent(input$Button1, {\n  #   shinyjs::disable(\"Button1\")\n  #   shinyjs::show(\"text1\")\n  #   plotReady$ok <- FALSE\n  #   # do some cool and complex stuff\n  #   Sys.sleep(2)\n  #   plotReady$ok <- TRUE\n  # })  \n\n  # output$plot <-renderPlot({\n  #   if (plotReady$ok) {\n  #     shinyjs::enable(\"Button1\")\n  #     shinyjs::hide(\"text1\")\n  #     hist(rnorm(100, 4, 1),breaks = 50)\n  #   }\n  # })\n\n}\n\nshinyApp(ui = ui, server = server)","type":"text"}]
