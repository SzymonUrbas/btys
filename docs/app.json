[{"name":"app.R","content":"library(shiny)\nlibrary(shinyjs)\nNplayer = 6\nNmilk = 4\n\nColPal = palette.colors(palette = \"Okabe-Ito\")\n\nmostProbCol = function(MilkMatrix){\n  freqTab = rep(0,ncol(MilkMatrix))\n  nmc = 1e3\n  iter = 0\n  while(iter<nmc){\n    tmp = apply(MilkMatrix,2,function(x){sample(x,1)})\n    idx = which(tmp == max(tmp))\n    freqTab[idx] = freqTab[idx]+1\n    iter = iter+1\n  }\n  return(which(freqTab == max(freqTab)))\n}\n\n# Define UI for random distribution app ----\nui <- fluidPage(\n  shinyjs::useShinyjs(),\n\n  # App title ----\n  titlePanel(\"Dairy Dynamics: Select the milk sample to get the highest score\"),\n  wellPanel(\n\n  # Sidebar layout with input and output definitions ----\n  sidebarLayout(\n\n    # Sidebar panel for inputs ----\n    sidebarPanel(\n\n      actionButton(\"updateData\", \"Next round\"),\n      actionButton(\"updateChoice\", \"Submit choice\"),\n      actionButton('resetButton',\"RESTART\"),\n\n      # Input: Selector for milk ----\n      selectInput(\"choice\", \"Make your choice:\",\n                  c(1:Nmilk)),\n      helpText(\"True values will be revealed after submitting a choice\"),\n\n      \n      # actionButton(\"Button1\", \"Run\"),\n      # shinyjs::hidden(p(id = \"text1\", \"Processing...\"))\n    ),\n\n    # Main panel for displaying outputs ----\n    mainPanel(\n\n      # Output: Tabset w/ plot, summary, and table ----\n      tabsetPanel(type = \"tabs\",\n                  tabPanel(\"Plot\", plotOutput(\"plot\")),\n                  tabPanel(\"Summary\", verbatimTextOutput(\"summary\"))\n      )\n\n    )\n  ))\n  # ,\n  # # wellPanel(\n  # #   fluidRow(verbatimTextOutput(\"phase\"))\n  # # )\n  ,\n  wellPanel(\n    fluidRow(tableOutput(\"Results\"))\n  )\n  ,\n  wellPanel(\n    fluidRow(plotOutput(\"ResultsPlot\"))\n  )\n\n)\n\n# Define server logic for random distribution app ----\nserver <- function(input, output, session) {\n\n  Accrued = reactiveVal(rep(0,Nplayer+1))\n  Niter = reactiveVal(0)\n\n  RunningAverage = reactiveVal(numeric(0))\n\n\n  currPhase = reactiveVal(TRUE) # !resultPhase\n\n  currResult = reactiveVal(NULL)\n\n  NPCchoice = reactiveVal(NULL)\n  shinyjs::disable(\"updateData\")\n\n  # initial ----\n  mus = rnorm(Nmilk)+100\n  sig = 1/rgamma(Nmilk, 5, 5)\n\n  x = matrix(rnorm(3e2*Nmilk,mus, sig),nrow = 3e3, ncol = Nmilk,\n            byrow = TRUE)\n  # boxplot(x)\n  MilkMatrix <- reactiveVal(x)\n\n\n  # eventReactive expression to generate the requested distribution ----\n\n\n  \n# ==========================================================================\n# Update the data ----\n# ==========================================================================\n  observeEvent(input$updateData,{\n\n    mus = rnorm(Nmilk)+100\n    sig = 1/rgamma(Nmilk, 5, 5)\n\n    x = matrix(rnorm(1e2*Nmilk,mus, sig),nrow = 1e3, ncol = Nmilk,\n              byrow = TRUE)\n    MilkMatrix(x)\n\n    newPhase = !currPhase()\n    currPhase(newPhase)\n    shinyjs::enable(\"updateChoice\")\n    shinyjs::disable(\"updateData\")\n  })\n  \n# ==========================================================================\n# Update the choice ----\n# ==========================================================================\n  observeEvent(input$updateChoice,{\n\n    currResult(sample(seq(Nmilk),1))\n\n\n    newPhase = !currPhase()\n    currPhase(newPhase)\n\n    tmpRes = MilkMatrix()[currResult(),]\n\n    tmpProfit = rep(0,Nplayer+1)\n\n\n    # Player ----\n    tmpProfit[1] = tmpRes[as.numeric(input$choice)]\n    # NPC ----\n\n    tmpSmm = rbind(colMeans(MilkMatrix()),\n                apply(MilkMatrix(), 2, quantile, probs = 0.025),\n                apply(MilkMatrix(), 2, quantile, probs = 0.975),\n                apply(MilkMatrix(),2, median)\n                )\n\n    tmpNPC = rep(NA, Nplayer)\n\n    tmpNPC[1] = which(tmpSmm[1,] == max(tmpSmm[1,]) )\n    tmpNPC[2] = which(tmpSmm[2,] == max(tmpSmm[2,]) )\n    tmpNPC[3] = which(tmpSmm[3,] == max(tmpSmm[3,]) )\n    tmpNPC[4] = which(tmpSmm[4,] == max(tmpSmm[4,]) )\n    tmpNPC[5] = mostProbCol(MilkMatrix())\n    tmpNPC[6] = sample(seq(Nmilk),1)\n\n\n    tmpProfit[2:7] = tmpRes[tmpNPC]\n\n    Accrued(Accrued() +tmpProfit)\n    print(tmpNPC)\n    NPCchoice(tmpNPC)\n\n\n    \n    Niter(Niter()+1)\n    RunningAverage(cbind(RunningAverage(),Accrued()/Niter()))\n\n\n    shinyjs::disable(\"updateChoice\")\n    shinyjs::enable(\"updateData\")\n  })\n\n\n\n  # Generate a plot of the data ----\n  # Also uses the inputs to build the plot label. Note that the\n  # dependencies on the inputs and the data reactive expression are\n  # both tracked, and all expressions are called in the sequence\n  # implied by the dependency graph.\n  output$plot <- renderPlot({\n    # boxplot(MilkMatrix())\n    yrng = range(MilkMatrix())\n    yrng[2] = yrng[2]+3\n    plot(0,0, type = 'l', xlim = c(0.8,Nmilk+0.2), ylim = yrng,\n      xlab = 'Milk option', ylab = 'Predicted Score', xaxt = 'n',\n      cex.lab = 1.4)\n    axis(1, at = 1:4, las = 1)\n    abline(h = seq(floor(yrng[1]), ceiling(yrng[2])), lty = 2,\n     col = 'grey', lwd = 0.5)\n    for(i in seq(Nmilk)){\n      lines(c(i,i), quantile(MilkMatrix()[,i],c(0.025,0.975)),\n       type = 'l', lwd = 18, col = 'grey')\n      points(c(i,i), quantile(MilkMatrix()[,i],c(0.025,0.975)),\n       lwd = 5, pch = c(24,25), cex = 1.5, bg = 'black')\n      points(i, mean(MilkMatrix()[,i]), pch = 16, cex = 3)\n    }\n\n\n\n    if(!currPhase()){\n      points(1:Nmilk, MilkMatrix()[currResult(),], lwd = 4, cex = 3,\n        bg = 'red', pch = 23, col = 'white')\n      ChoiceCounts = rep(0,Nmilk)\n      text(as.numeric(input$choice),yrng[2], \"Player\", cex = 1.5)\n      ChoiceCounts[as.numeric(input$choice)] = ChoiceCounts[as.numeric(input$choice)]+1\n\n      for(i in seq(Nplayer)){\n        NPCtmp = as.numeric(NPCchoice()[i])\n        text(NPCtmp,yrng[2] - diff(yrng)*0.06*ChoiceCounts[NPCtmp], paste0(\"NPC \",i), cex = 1.5,\n          col = ColPal[i+1])\n        ChoiceCounts[NPCtmp] = ChoiceCounts[NPCtmp]+1\n      }\n      # points(as.numeric(input$choice), MilkMatrix()[currResult(),][as.numeric(input$choice)],\n      #    col = 'blue', lwd = 3, pch = 3)\n\n      # points(NPCchoice(), MilkMatrix()[currResult(),][NPCchoice()],\n      #    col = 'green', lwd = 3, pch = 3)\n\n    }\n  })\n\n  # Generate a summary of the data ----\n  output$summary <- renderPrint({\n    summary(MilkMatrix())\n  })\n\n  # # Generate an HTML table view of the data ----\n  # output$table <- renderTable({\n  #   head(MilkMatrix())\n  # })\n\n  output$Results <- renderTable({\n    # tmp = Accrued()\n    # names(tmp) = c(\"Player\", paste0(\"NPC_\",1:Nplayer))\n    # tmp\n    tmp = data.frame(matrix(Accrued(),1,Nplayer+1))\n    colnames(tmp) = c(\"Player\", paste0(\"NPC_\",1:Nplayer))\n    rownames(tmp) = c(\"Total score\")\n    tmp\n  }, rownames = TRUE)\n\n  output$ResultsPlot <- renderPlot({\n    # print(paste0(\"Niter():\",as.numeric(Niter())))\n    # print(paste0(\"RunningAverage():\",as.matrix(RunningAverage())))\n    Iter = as.numeric(Niter())\n    CurrRA = as.matrix(RunningAverage())\n    if(Iter == 0){\n      plot(0,0, type = 'l', xlab = '', ylab = '', xaxt = 'n', yaxt = 'n',\n        main = 'Play the game to see results')\n      # text(0,0, 'Play the game to see results', cex = 3)\n    } else if(Iter<11) {\n      # print(Iter)\n      plot(0,0, type = 'l', ylim = range(CurrRA), xlim = c(1,(Iter)),\n        xlab = 'Round', main = 'Running average results', ylab = '')\n        for(i in 1:(Nplayer+1)){\n          lines(1:Iter, CurrRA[i,], col = i, lty = i, lwd = 3)\n          points(Iter, CurrRA[i,Iter], col = i, lwd = 3, cex = 2, pch = 16)\n        }\n        legend('topleft', legend = c('Player', paste('NPC', seq(Nplayer))),\n                lty = 1:8, col = ColPal[1:8], lwd =3, pch = 16)\n\n    } else {\n      plot(0,0, type = 'l', ylim = range(CurrRA[,(Iter-10):Iter]), xlim = c(Iter-10,Iter),\n        xlab = 'Round', main = 'Running average results', ylab = '')\n      for(i in (Nplayer+1):1){\n        lines((Iter-10):Iter, CurrRA[i,(Iter-10):Iter], col = ColPal[i], lty = i, lwd = 3)\n        points(Iter, CurrRA[i,Iter], col = ColPal[i], lwd = 3, cex = 2, pch = 16)\n      }\n      legend('topleft', legend = c('Player', paste('NPC', seq(Nplayer))),\n              lty = 1:8, col = ColPal[1:8], lwd =3, pch = 16)\n\n    }\n    \n    # tmp = Accrued()\n    # names(tmp) = c(\"Player\", paste0(\"NPC_\",1:Nplayer))\n    # tmp\n    # tmp = data.frame(matrix(Accrued(),1,Nplayer+1))\n    # colnames(tmp) = c(\"Player\", paste0(\"NPC_\",1:Nplayer))\n    # tmp\n  })\n\n\n\n  output$phase <- renderPrint({\n    cat(paste0(\"currPhase:\", currPhase(),\"\\n\",\n      \"profit: \", Accrued()[1],\"\\n\",\n      \"runningAverage: \", round(Accrued()/Niter(),2))[1])\n  })\n\n  observeEvent(input$resetButton,{\n    aggg_result = -1\n    if(aggg_result == -1)\n    {\n      session$reload()\n      return()\n      print(\"session reload not working\")\n    }\n\n    print(\"Code running this line\")\n\n    output$code_ran <- renderText(\"code Ran this line without refreshing\")\n\n  })\n\n  # plotReady <- reactiveValues(ok = FALSE)\n\n  # observeEvent(input$Button1, {\n  #   shinyjs::disable(\"Button1\")\n  #   shinyjs::show(\"text1\")\n  #   plotReady$ok <- FALSE\n  #   # do some cool and complex stuff\n  #   Sys.sleep(2)\n  #   plotReady$ok <- TRUE\n  # })  \n\n  # output$plot <-renderPlot({\n  #   if (plotReady$ok) {\n  #     shinyjs::enable(\"Button1\")\n  #     shinyjs::hide(\"text1\")\n  #     hist(rnorm(100, 4, 1),breaks = 50)\n  #   }\n  # })\n\n}\n\nshinyApp(ui = ui, server = server)","type":"text"}]
